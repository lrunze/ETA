(array(int8, 1d, C),)//////////////; ModuleID = 'sum2d'
source_filename = "<string>"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-windows-msvc"

@.const.picklebuf.2160626969800 = internal constant { i8*, i32 } { i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.const.pickledata.2160626969800, i32 0, i32 0), i32 66 }
@".const.%s" = internal constant [3 x i8] c"%s\00"
@".const.the print() function" = internal constant [21 x i8] c"the print() function\00"
@".const.\0A" = internal constant [2 x i8] c"\0A\00"
@.const.pickledata.2160626969800 = internal constant [66 x i8] c"\80\04\957\00\00\00\00\00\00\00\8C\08builtins\94\8C\0CRuntimeError\94\93\94\8C\13missing Environment\94\85\94\86\94."
@.const.sum2d = internal constant [6 x i8] c"sum2d\00"
@".const.Fatal error: missing _dynfunc.Closure" = internal constant [38 x i8] c"Fatal error: missing _dynfunc.Closure\00"
@PyExc_RuntimeError = external global i8
@".const.missing Environment" = internal constant [20 x i8] c"missing Environment\00"
@_Py_NoneStruct = external global i8
@PyExc_StopIteration = external global i8
@PyExc_SystemError = external global i8
@".const.unknown error when calling native function" = internal constant [43 x i8] c"unknown error when calling native function\00"

define i32 @"_ZN8__main__9sum2d$241E5ArrayIaLi1E1C7mutable7alignedE"(double* noalias nocapture %retptr, { i8*, i32 }** noalias nocapture %excinfo, i8* noalias nocapture readnone %env, i8* nocapture readnone %arg.arr.0, i8* nocapture readnone %arg.arr.1, i64 %arg.arr.2, i64 %arg.arr.3, i8* nocapture readonly %arg.arr.4, i64 %arg.arr.5.0, i64 %arg.arr.6.0) local_unnamed_addr {
entry:
  %.448 = alloca i32, align 4
  %.106 = add i64 %arg.arr.2, -1
  %.107 = icmp sgt i64 %.106, 0
  br i1 %.107, label %B32.lr.ph, label %B383

B32.lr.ph:                                        ; preds = %entry
  %.450 = icmp eq i8* %env, null
  br i1 %.450, label %B32.lr.ph.split.us, label %B32.preheader, !prof !0

B32.preheader:                                    ; preds = %B32.lr.ph
  %scevgep25 = getelementptr i8, i8* %arg.arr.4, i64 1
  br label %B32

B32.lr.ph.split.us:                               ; preds = %B32.lr.ph
  %.232.us.pre = load i8, i8* %arg.arr.4, align 1
  %scevgep = getelementptr i8, i8* %arg.arr.4, i64 1
  br label %B32.us

B32.us:                                           ; preds = %B380.us, %B32.lr.ph.split.us
  %lsr.iv21 = phi i8* [ %scevgep22, %B380.us ], [ %scevgep, %B32.lr.ph.split.us ]
  %lsr.iv = phi i64 [ %lsr.iv.next, %B380.us ], [ %arg.arr.2, %B32.lr.ph.split.us ]
  %.232.us = phi i8 [ %.232.us.pre, %B32.lr.ph.split.us ], [ %.267.us, %B380.us ]
  %aa.012.us = phi double [ 0.000000e+00, %B32.lr.ph.split.us ], [ %aa.1.us, %B380.us ]
  %bb.011.us = phi i64 [ 0, %B32.lr.ph.split.us ], [ %bb.1.us, %B380.us ]
  %cc.010.us = phi double [ 0.000000e+00, %B32.lr.ph.split.us ], [ %cc.1.us, %B380.us ]
  %.267.us = load i8, i8* %lsr.iv21, align 1
  switch i8 %.232.us, label %B380.us [
    i8 0, label %B62.us
    i8 2, label %B198.us
    i8 3, label %B290.us
  ]

B290.us:                                          ; preds = %B32.us
  %.781.us = icmp eq i8 %.267.us, 0
  br i1 %.781.us, label %B300.us, label %B370.us

B370.us:                                          ; preds = %B290.us
  %.932.us = fadd double %cc.010.us, 3.320000e+02
  br label %B380.us

B300.us:                                          ; preds = %B290.us
  %.799.us = fadd double %aa.012.us, 8.000000e+00
  br label %B380.us

B198.us:                                          ; preds = %B32.us
  %.591.us = icmp eq i8 %.267.us, 0
  br i1 %.591.us, label %B206.us, label %B272.us

B272.us:                                          ; preds = %B198.us
  %.742.us = fadd double %cc.010.us, 3.320000e+02
  br label %B380.us

B206.us:                                          ; preds = %B198.us
  %.609.us = fadd double %aa.012.us, 8.000000e+00
  br label %B380.us

B62.us:                                           ; preds = %B32.us
  switch i8 %.267.us, label %B178.us [
    i8 0, label %B70.us
    i8 1, label %B88.us
    i8 88, label %B110.endif.us
    i8 3, label %B132.us
    i8 4, label %B150.us
    i8 5, label %B168.us
  ]

B168.us:                                          ; preds = %B62.us
  %.533.us = sitofp i64 %bb.011.us to double
  %.534.us = fadd double %cc.010.us, %.533.us
  br label %B380.us

B150.us:                                          ; preds = %B62.us
  %.501.us = fadd double %cc.010.us, %aa.012.us
  br label %B380.us

B132.us:                                          ; preds = %B62.us
  call void @numba_gil_ensure(i32* nonnull %.448)
  store { i8*, i32 }* @.const.picklebuf.2160626969800, { i8*, i32 }** %excinfo, align 8
  ret i32 1

B110.endif.us:                                    ; preds = %B62.us
  %.403.us = fdiv double %aa.012.us, 9.000000e+00
  br label %B380.us

B88.us:                                           ; preds = %B62.us
  %.353.us = fmul double %aa.012.us, 9.000000e+00
  br label %B380.us

B70.us:                                           ; preds = %B62.us
  %.315.us = fadd double %aa.012.us, 8.000000e+00
  br label %B380.us

B178.us:                                          ; preds = %B62.us
  %.552.us = fadd double %cc.010.us, 3.320000e+02
  br label %B380.us

B380.us:                                          ; preds = %B178.us, %B70.us, %B88.us, %B110.endif.us, %B150.us, %B168.us, %B206.us, %B272.us, %B300.us, %B370.us, %B32.us
  %cc.1.us = phi double [ %cc.010.us, %B70.us ], [ %cc.010.us, %B88.us ], [ 9.000000e+00, %B110.endif.us ], [ %.501.us, %B150.us ], [ %.534.us, %B168.us ], [ %.552.us, %B178.us ], [ %cc.010.us, %B206.us ], [ %.742.us, %B272.us ], [ %cc.010.us, %B300.us ], [ %.932.us, %B370.us ], [ %cc.010.us, %B32.us ]
  %bb.1.us = phi i64 [ %bb.011.us, %B70.us ], [ 1, %B88.us ], [ %bb.011.us, %B110.endif.us ], [ %bb.011.us, %B150.us ], [ %bb.011.us, %B168.us ], [ %bb.011.us, %B178.us ], [ %bb.011.us, %B206.us ], [ %bb.011.us, %B272.us ], [ %bb.011.us, %B300.us ], [ %bb.011.us, %B370.us ], [ %bb.011.us, %B32.us ]
  %aa.1.us = phi double [ %.315.us, %B70.us ], [ %.353.us, %B88.us ], [ %.403.us, %B110.endif.us ], [ %aa.012.us, %B150.us ], [ %aa.012.us, %B168.us ], [ %aa.012.us, %B178.us ], [ %.609.us, %B206.us ], [ %aa.012.us, %B272.us ], [ %.799.us, %B300.us ], [ %aa.012.us, %B370.us ], [ %aa.012.us, %B32.us ]
  %lsr.iv.next = add i64 %lsr.iv, -1
  %scevgep22 = getelementptr i8, i8* %lsr.iv21, i64 1
  %.146.us = icmp sgt i64 %lsr.iv.next, 1
  br i1 %.146.us, label %B32.us, label %B383

B32:                                              ; preds = %B32.preheader, %B380
  %lsr.iv26 = phi i8* [ %scevgep25, %B32.preheader ], [ %scevgep27, %B380 ]
  %lsr.iv23 = phi i64 [ %arg.arr.2, %B32.preheader ], [ %lsr.iv.next24, %B380 ]
  %aa.012 = phi double [ %aa.1, %B380 ], [ 0.000000e+00, %B32.preheader ]
  %bb.011 = phi i64 [ %bb.1, %B380 ], [ 0, %B32.preheader ]
  %cc.010 = phi double [ %cc.1, %B380 ], [ 0.000000e+00, %B32.preheader ]
  %scevgep28 = getelementptr i8, i8* %lsr.iv26, i64 -1
  %.232 = load i8, i8* %scevgep28, align 1
  %.267 = load i8, i8* %lsr.iv26, align 1
  switch i8 %.232, label %B380 [
    i8 0, label %B62
    i8 2, label %B198
    i8 3, label %B290
  ]

B62:                                              ; preds = %B32
  switch i8 %.267, label %B178 [
    i8 0, label %B70
    i8 1, label %B88
    i8 88, label %B110.endif
    i8 3, label %B132
    i8 4, label %B150
    i8 5, label %B168
  ]

B70:                                              ; preds = %B62
  %.315 = fadd double %aa.012, 8.000000e+00
  br label %B380

B88:                                              ; preds = %B62
  %.353 = fmul double %aa.012, 9.000000e+00
  br label %B380

B132:                                             ; preds = %B62
  call void @numba_gil_ensure(i32* nonnull %.448)
  %.459 = call i8* @PyLong_FromLongLong(i64 9)
  %.462 = icmp eq i8* %.459, null
  br i1 %.462, label %B132.endif.else, label %B132.endif.if, !prof !0

B150:                                             ; preds = %B62
  %.501 = fadd double %cc.010, %aa.012
  br label %B380

B168:                                             ; preds = %B62
  %.533 = sitofp i64 %bb.011 to double
  %.534 = fadd double %cc.010, %.533
  br label %B380

B178:                                             ; preds = %B62
  %.552 = fadd double %cc.010, 3.320000e+02
  br label %B380

B198:                                             ; preds = %B32
  %.591 = icmp eq i8 %.267, 0
  br i1 %.591, label %B206, label %B272

B206:                                             ; preds = %B198
  %.609 = fadd double %aa.012, 8.000000e+00
  br label %B380

B272:                                             ; preds = %B198
  %.742 = fadd double %cc.010, 3.320000e+02
  br label %B380

B290:                                             ; preds = %B32
  %.781 = icmp eq i8 %.267, 0
  br i1 %.781, label %B300, label %B370

B300:                                             ; preds = %B290
  %.799 = fadd double %aa.012, 8.000000e+00
  br label %B380

B370:                                             ; preds = %B290
  %.932 = fadd double %cc.010, 3.320000e+02
  br label %B380

B380:                                             ; preds = %B32, %B132.endif.endif, %B110.endif, %B370, %B300, %B272, %B206, %B178, %B168, %B150, %B88, %B70
  %cc.1 = phi double [ %cc.010, %B70 ], [ %cc.010, %B88 ], [ 9.000000e+00, %B110.endif ], [ %cc.010, %B132.endif.endif ], [ %.501, %B150 ], [ %.534, %B168 ], [ %.552, %B178 ], [ %cc.010, %B206 ], [ %.742, %B272 ], [ %cc.010, %B300 ], [ %.932, %B370 ], [ %cc.010, %B32 ]
  %bb.1 = phi i64 [ %bb.011, %B70 ], [ 1, %B88 ], [ %bb.011, %B110.endif ], [ %bb.011, %B132.endif.endif ], [ %bb.011, %B150 ], [ %bb.011, %B168 ], [ %bb.011, %B178 ], [ %bb.011, %B206 ], [ %bb.011, %B272 ], [ %bb.011, %B300 ], [ %bb.011, %B370 ], [ %bb.011, %B32 ]
  %aa.1 = phi double [ %.315, %B70 ], [ %.353, %B88 ], [ %.403, %B110.endif ], [ %aa.012, %B132.endif.endif ], [ %aa.012, %B150 ], [ %aa.012, %B168 ], [ %aa.012, %B178 ], [ %.609, %B206 ], [ %aa.012, %B272 ], [ %.799, %B300 ], [ %aa.012, %B370 ], [ %aa.012, %B32 ]
  %lsr.iv.next24 = add i64 %lsr.iv23, -1
  %scevgep27 = getelementptr i8, i8* %lsr.iv26, i64 1
  %.146 = icmp sgt i64 %lsr.iv.next24, 1
  br i1 %.146, label %B32, label %B383

B383:                                             ; preds = %B380, %B380.us, %entry
  %cc.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %cc.1.us, %B380.us ], [ %cc.1, %B380 ]
  %bb.0.lcssa = phi i64 [ 0, %entry ], [ %bb.1.us, %B380.us ], [ %bb.1, %B380 ]
  %aa.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %aa.1.us, %B380.us ], [ %aa.1, %B380 ]
  %.960 = sitofp i64 %bb.0.lcssa to double
  %.961 = fadd double %aa.0.lcssa, %.960
  %.971 = fadd double %cc.0.lcssa, %.961
  store double %.971, double* %retptr, align 8
  ret i32 0

B110.endif:                                       ; preds = %B62
  %.403 = fdiv double %aa.012, 9.000000e+00
  br label %B380

B132.endif.if:                                    ; preds = %B132
  %.464 = call i8* @PyObject_Str(i8* nonnull %.459)
  %.465 = call i8* @PyUnicode_AsUTF8(i8* %.464)
  call void (i8*, ...) @PySys_WriteStdout(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @".const.%s", i64 0, i64 0), i8* %.465)
  call void @Py_DecRef(i8* %.464)
  call void @Py_DecRef(i8* nonnull %.459)
  br label %B132.endif.endif

B132.endif.else:                                  ; preds = %B132
  %.470 = call i8* @PyUnicode_FromString(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @".const.the print() function", i64 0, i64 0))
  call void @PyErr_WriteUnraisable(i8* %.470)
  call void @Py_DecRef(i8* %.470)
  br label %B132.endif.endif

B132.endif.endif:                                 ; preds = %B132.endif.else, %B132.endif.if
  call void (i8*, ...) @PySys_WriteStdout(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @".const.\0A", i64 0, i64 0))
  call void @numba_gil_release(i32* nonnull %.448)
  br label %B380
}

declare void @numba_gil_ensure(i32*) local_unnamed_addr

declare i8* @PyLong_FromLongLong(i64) local_unnamed_addr

declare i8* @PyObject_Str(i8*) local_unnamed_addr

declare i8* @PyUnicode_AsUTF8(i8*) local_unnamed_addr

declare void @PySys_WriteStdout(i8*, ...) local_unnamed_addr

declare void @Py_DecRef(i8*) local_unnamed_addr

declare i8* @PyUnicode_FromString(i8*) local_unnamed_addr

declare void @PyErr_WriteUnraisable(i8*) local_unnamed_addr

declare void @numba_gil_release(i32*) local_unnamed_addr

define i8* @"_ZN7cpython8__main__9sum2d$241E5ArrayIaLi1E1C7mutable7alignedE"(i8* %py_closure, i8* %py_args, i8* nocapture readnone %py_kws) local_unnamed_addr {
entry:
  %.5 = alloca i8*, align 8
  %.6 = call i32 (i8*, i8*, i64, i64, ...) @PyArg_UnpackTuple(i8* %py_args, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.const.sum2d, i64 0, i64 0), i64 1, i64 1, i8** nonnull %.5)
  %.7 = icmp eq i32 %.6, 0
  %.30 = alloca { i8*, i8*, i64, i64, i8*, [1 x i64], [1 x i64] }, align 8
  %.40 = alloca double, align 8
  %excinfo = alloca { i8*, i32 }*, align 8
  %0 = bitcast { i8*, i8*, i64, i64, i8*, [1 x i64], [1 x i64] }* %.30 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull %0, i8 0, i64 56, i32 8, i1 false)
  br i1 %.7, label %entry.if, label %entry.endif, !prof !0

entry.if:                                         ; preds = %entry.endif.endif.endif.endif.endif.if, %entry.endif.endif.endif, %entry.endif.endif.endif.endif.endif.endif, %entry.endif.endif.endif.endif.endif.if.if, %entry.endif.endif.endif.endif.endif.endif.if, %entry.endif.endif.endif.endif.endif.endif.endif.endif, %entry
  ret i8* null

entry.endif:                                      ; preds = %entry
  %.11 = icmp eq i8* %py_closure, null
  br i1 %.11, label %entry.endif.if, label %entry.endif.endif, !prof !0

entry.endif.if:                                   ; preds = %entry.endif
  %.13 = call i32 @puts(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @".const.Fatal error: missing _dynfunc.Closure", i64 0, i64 0))
  unreachable

entry.endif.endif:                                ; preds = %entry.endif
  %.15 = ptrtoint i8* %py_closure to i64
  %.16 = add i64 %.15, 24
  %.18 = inttoptr i64 %.16 to { i8* }*
  %.192 = bitcast { i8* }* %.18 to i8**
  %.20 = load i8*, i8** %.192, align 8
  %.25 = icmp eq i8* %.20, null
  br i1 %.25, label %entry.endif.endif.if, label %entry.endif.endif.endif, !prof !0

entry.endif.endif.if:                             ; preds = %entry.endif.endif
  call void @PyErr_SetString(i8* nonnull @PyExc_RuntimeError, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @".const.missing Environment", i64 0, i64 0))
  ret i8* null

entry.endif.endif.endif:                          ; preds = %entry.endif.endif
  %1 = bitcast { i8*, i8*, i64, i64, i8*, [1 x i64], [1 x i64] }* %.30 to i8**
  %.29 = load i8*, i8** %.5, align 8
  %.32 = bitcast { i8*, i8*, i64, i64, i8*, [1 x i64], [1 x i64] }* %.30 to i8*
  %.33 = call i32 @NRT_adapt_ndarray_from_python(i8* %.29, i8* nonnull %.32)
  %.34 = icmp eq i32 %.33, 0
  %.35.fca.0.load = load i8*, i8** %1, align 8
  br i1 %.34, label %entry.endif.endif.endif.endif, label %entry.if, !prof !1

entry.endif.endif.endif.endif:                    ; preds = %entry.endif.endif.endif
  %2 = bitcast { i8*, i8*, i64, i64, i8*, [1 x i64], [1 x i64] }* %.30 to i8*
  %sunkaddr = getelementptr i8, i8* %2, i64 8
  %3 = bitcast i8* %sunkaddr to i8**
  %.35.fca.1.load = load i8*, i8** %3, align 8
  %4 = bitcast { i8*, i8*, i64, i64, i8*, [1 x i64], [1 x i64] }* %.30 to i8*
  %sunkaddr3 = getelementptr i8, i8* %4, i64 16
  %5 = bitcast i8* %sunkaddr3 to i64*
  %.35.fca.2.load = load i64, i64* %5, align 8
  %6 = bitcast { i8*, i8*, i64, i64, i8*, [1 x i64], [1 x i64] }* %.30 to i8*
  %sunkaddr4 = getelementptr i8, i8* %6, i64 24
  %7 = bitcast i8* %sunkaddr4 to i64*
  %.35.fca.3.load = load i64, i64* %7, align 8
  %8 = bitcast { i8*, i8*, i64, i64, i8*, [1 x i64], [1 x i64] }* %.30 to i8*
  %sunkaddr5 = getelementptr i8, i8* %8, i64 32
  %9 = bitcast i8* %sunkaddr5 to i8**
  %.35.fca.4.load = load i8*, i8** %9, align 8
  %10 = bitcast { i8*, i8*, i64, i64, i8*, [1 x i64], [1 x i64] }* %.30 to i8*
  %sunkaddr6 = getelementptr i8, i8* %10, i64 40
  %11 = bitcast i8* %sunkaddr6 to i64*
  %.35.fca.5.0.load = load i64, i64* %11, align 8
  %12 = bitcast { i8*, i8*, i64, i64, i8*, [1 x i64], [1 x i64] }* %.30 to i8*
  %sunkaddr7 = getelementptr i8, i8* %12, i64 48
  %13 = bitcast i8* %sunkaddr7 to i64*
  %.35.fca.6.0.load = load i64, i64* %13, align 8
  store double 0.000000e+00, double* %.40, align 8
  %.44 = call i32 @"_ZN8__main__9sum2d$241E5ArrayIaLi1E1C7mutable7alignedE"(double* nonnull %.40, { i8*, i32 }** nonnull %excinfo, i8* nonnull %.20, i8* %.35.fca.0.load, i8* %.35.fca.1.load, i64 %.35.fca.2.load, i64 %.35.fca.3.load, i8* %.35.fca.4.load, i64 %.35.fca.5.0.load, i64 %.35.fca.6.0.load)
  %.45 = load { i8*, i32 }*, { i8*, i32 }** %excinfo, align 8
  %.54 = load double, double* %.40, align 8
  call void @NRT_decref(i8* %.35.fca.0.load)
  switch i32 %.44, label %entry.endif.endif.endif.endif.endif [
    i32 -2, label %entry.endif.endif.endif.endif.if.if
    i32 0, label %entry.endif.endif.endif.endif.if.endif
  ]

entry.endif.endif.endif.endif.endif:              ; preds = %entry.endif.endif.endif.endif
  %.52 = icmp sgt i32 %.44, 0
  br i1 %.52, label %entry.endif.endif.endif.endif.endif.if, label %entry.endif.endif.endif.endif.endif.endif

entry.endif.endif.endif.endif.if.if:              ; preds = %entry.endif.endif.endif.endif
  call void @Py_IncRef(i8* nonnull @_Py_NoneStruct)
  ret i8* @_Py_NoneStruct

entry.endif.endif.endif.endif.if.endif:           ; preds = %entry.endif.endif.endif.endif
  %.60 = call i8* @PyFloat_FromDouble(double %.54)
  ret i8* %.60

entry.endif.endif.endif.endif.endif.if:           ; preds = %entry.endif.endif.endif.endif.endif
  call void @PyErr_Clear()
  %.65 = load { i8*, i32 }, { i8*, i32 }* %.45, align 8
  %.66 = extractvalue { i8*, i32 } %.65, 0
  %.68 = extractvalue { i8*, i32 } %.65, 1
  %.69 = call i8* @numba_unpickle(i8* %.66, i32 %.68)
  %.70 = icmp eq i8* %.69, null
  br i1 %.70, label %entry.if, label %entry.endif.endif.endif.endif.endif.if.if, !prof !0

entry.endif.endif.endif.endif.endif.endif:        ; preds = %entry.endif.endif.endif.endif.endif
  switch i32 %.44, label %entry.endif.endif.endif.endif.endif.endif.endif.endif [
    i32 -3, label %entry.endif.endif.endif.endif.endif.endif.if
    i32 -1, label %entry.if
  ]

entry.endif.endif.endif.endif.endif.if.if:        ; preds = %entry.endif.endif.endif.endif.endif.if
  call void @numba_do_raise(i8* nonnull %.69)
  br label %entry.if

entry.endif.endif.endif.endif.endif.endif.if:     ; preds = %entry.endif.endif.endif.endif.endif.endif
  call void @PyErr_SetNone(i8* nonnull @PyExc_StopIteration)
  br label %entry.if

entry.endif.endif.endif.endif.endif.endif.endif.endif: ; preds = %entry.endif.endif.endif.endif.endif.endif
  call void @PyErr_SetString(i8* nonnull @PyExc_SystemError, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @".const.unknown error when calling native function", i64 0, i64 0))
  br label %entry.if
}

declare i32 @PyArg_UnpackTuple(i8*, i8*, i64, i64, ...) local_unnamed_addr

; Function Attrs: nounwind
declare i32 @puts(i8* nocapture readonly) local_unnamed_addr #0

declare void @PyErr_SetString(i8*, i8*) local_unnamed_addr

declare i32 @NRT_adapt_ndarray_from_python(i8* nocapture, i8* nocapture) local_unnamed_addr

declare void @Py_IncRef(i8*) local_unnamed_addr

declare i8* @PyFloat_FromDouble(double) local_unnamed_addr

declare void @PyErr_Clear() local_unnamed_addr

declare i8* @numba_unpickle(i8*, i32) local_unnamed_addr

declare void @numba_do_raise(i8*) local_unnamed_addr

declare void @PyErr_SetNone(i8*) local_unnamed_addr

; Function Attrs: noinline
define linkonce_odr void @NRT_decref(i8* %.1) local_unnamed_addr #1 {
.3:
  %.4 = icmp eq i8* %.1, null
  br i1 %.4, label %.3.if, label %.3.endif, !prof !0

.3.if:                                            ; preds = %.3.endif, %.3
  ret void

.3.endif:                                         ; preds = %.3
  %.7 = bitcast i8* %.1 to i64*
  %.4.i = atomicrmw sub i64* %.7, i64 1 monotonic
  %.9 = icmp eq i64 %.4.i, 1
  br i1 %.9, label %.3.endif.if, label %.3.if, !prof !0

.3.endif.if:                                      ; preds = %.3.endif
  tail call void @NRT_MemInfo_call_dtor(i8* nonnull %.1)
  ret void
}

declare void @NRT_MemInfo_call_dtor(i8*) local_unnamed_addr

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #2

; Function Attrs: nounwind
declare void @llvm.stackprotector(i8*, i8**) #0

attributes #0 = { nounwind }
attributes #1 = { noinline }
attributes #2 = { argmemonly nounwind }

!0 = !{!"branch_weights", i32 1, i32 99}
!1 = !{!"branch_weights", i32 99, i32 1}
