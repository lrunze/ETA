{"vi_templatejg59migx":"{\"nodes\":[{\"x\":152,\"y\":120,\"fixed\":true,\"text\":\"a\",\"px\":152,\"py\":120,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"1\"}],\"usercode\":\"a:\\n    emit(3,0)#90000000\"}","vi_templatejfc9koma":"{\"nodes\":[{\"x\":82,\"y\":81,\"fixed\":true,\"text\":\"a\",\"px\":82,\"py\":81,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"0\"}],\"usercode\":\"a:\\n    emit(2,0)\"}","vi_templatejg52ksbp":"{\"nodes\":[{\"x\":374,\"y\":109,\"fixed\":true,\"text\":\"start\",\"px\":374,\"py\":109},{\"x\":101,\"y\":103,\"fixed\":true,\"text\":\"stop\",\"px\":101,\"py\":103,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"3\"},{\"source\":1,\"target\":0,\"text\":\"2\"},{\"source\":0,\"target\":0,\"text\":\"2\"},{\"source\":1,\"target\":1,\"text\":\"3\"}],\"usercode\":\"HISTOGRAM(h3,(`bins`,`binsize`))\\nINTEGER(i1,0)\\nCLOCK(c3,100,1)\\nstart:\\n    {i1+=AbsTime_ps}\\n    c3.start()\\n\\nstop:\\n    c3.stop()\\n    h3.record(c3)\\n\"}","vi_templatejfb2qshf":"{\"nodes\":[{\"x\":346,\"y\":111,\"fixed\":true,\"text\":\"start\",\"px\":346,\"py\":111},{\"x\":75,\"y\":66,\"fixed\":true,\"text\":\"stop\",\"px\":75,\"py\":66,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"2\"},{\"source\":1,\"target\":0,\"text\":\"3\"},{\"source\":0,\"target\":0,\"text\":\"3\"},{\"source\":1,\"target\":1,\"text\":\"2\"}],\"usercode\":\"HISTOGRAM(h4,(`bins`,`binsize`))\\nCLOCK(c4,100,1)\\nstart:\\n    c4.start()\\nstop:\\n    c4.stop()\\n    h4.record(c4)\"}","dpp_template_code":"#------IMPORTS-----\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom os import path\r\nfrom matplotlib.widgets import Button\r\n\r\n\r\n#-----PLOTTING----\r\nplt.ion()\r\nfig, ax = plt.subplots()\r\nplt.subplots_adjust(bottom=0.2)\r\nline1, = ax.plot([], [], 'r-') # Returns a tuple of line objects, thus the comma\r\nax.set_ylabel('Histogram events')\r\nax.set_xlabel('Time delay (ps)')\r\nax.set_title(expname)\r\n\r\n#-----BUTTONS----\r\ndata_last=None\r\ndata_now=None\r\ndef clear_graph(event): #clears the graph\r\n    global data_last\r\n    global data_now\r\n    global np\r\n    data_last=np.copy(data_now)\r\n    print(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\")\r\n    \r\nbase=None\r\ndef mode(event): #switches between alignment mode and accumulation mode\r\n    global base, ctx1, y_max\r\n    y_max = 1\r\n    if base == None:\r\n        base = ctx1\r\n    else:\r\n        base = None\r\n\r\nlog = False\r\ny_min = 0\r\ny_max = 1\r\ndef linlog(event): #switches between log and linear scale for the y axis\r\n        global ax, plt, log, y_min\r\n        if log==True:\r\n            ax.set_yscale(\"linear\")\r\n            log=False\r\n            y_min=0\r\n        else:\r\n            ax.set_yscale(\"log\", nonposy='clip')\r\n            log=True\r\n            y_min=0.5\r\n\r\n\r\naxmode = plt.axes([0.7, 0.05, 0.1, 0.075])\r\naxlinlog = plt.axes([0.81, 0.05, 0.1, 0.075])\r\nblinlog = Button(axlinlog, 'Lin/Log')\r\nbmode = Button(axmode, 'Mode')\r\nblinlog.on_clicked(linlog)\r\nbmode.on_clicked(mode)\r\n\r\n#------ETA PROCESSING-----\r\nrecords_per_cut = int(records_per_cut)\r\nbinsize=int(binsize)\r\ncut=None\r\nctx1=None\r\neta.send(\"ETA is running in realtime...\", \"running\")\r\nfirst_run = True\r\nwhile True:\r\n    try:\r\n        cut=eta.incremental_cut(file,cut=cut, rec_per_cut=records_per_cut,verbose=False)\r\n    except Exception as e:\r\n        eta.send(str(e),\"err\")\r\n        break\r\n    \r\n    if not(eta.wait_till_presnese(cut,timeout=1.0)):\r\n        break\r\n    result,ctx1 = eta.run(cut, group='main',\r\n       ctxs= base,sum_results=True,iterate_ctxs=True,verbose=False)\r\n    \r\n    t1=result[\"h3\"]\r\n    t2=result[\"h4\"] \r\n    \r\n    if first_run:\r\n        ax.set_xlim(-t2.size*binsize,t1.size*binsize)\r\n        first_run = False\r\n    data_now=np.copy(np.concatenate((np.flip(t2, 0), t1), axis=0))\r\n    if data_last is not None:\r\n        data_draw=data_now-data_last\r\n    else:\r\n        data_draw=data_now\r\n    try:\r\n        if np.amax(data_draw)>=y_max*0.95:\r\n            y_max=np.amax(data_draw)*3\r\n        ax.set_ylim(y_min,y_max)\r\n        line1.set_xdata(np.arange(-t2.size,t1.size)*binsize)\r\n        line1.set_ydata(data_draw)\r\n        fig.canvas.draw()\r\n        fig.canvas.flush_events()\r\n    except Exception as e:\r\n        #eta.send(str(e),\"err\")\r\n        break\r\neta.send(\"ETA realtime is stopped.\", \"stopped\")\r\nplt.close()","eta_index_table":"[{\"id\":\"var_templatejgmgopco\",\"name\":\"file\",\"group\":\"main\",\"info\":\"\",\"config\":\"C:/YourFolder/YourFile.ptu\"},{\"id\":\"var_templatejkil9dn6\",\"name\":\"binsize\",\"group\":\"main\",\"info\":\"\",\"config\":\"16\"},{\"id\":\"var_templatejkil7pz1\",\"name\":\"records_per_cut\",\"group\":\"main\",\"info\":\"\",\"config\":\"200000\"},{\"id\":\"var_templatejkil6yh0\",\"name\":\"expname\",\"group\":\"main\",\"info\":\"\",\"config\":\"Realtime\"},{\"id\":\"var_templatejkil8r7x\",\"name\":\"bins\",\"group\":\"main\",\"info\":\"\",\"config\":\"10000\"},{\"id\":\"dpp_template_code\",\"name\":\"realtime\",\"group\":\"main\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatejouvphfp\",\"name\":\"qutag_start_recording\",\"group\":\"main\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatejouvvpsn\",\"name\":\"swebianinstrument_start_recording\",\"group\":\"main\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatejouvx190\",\"name\":\"hydraharp_start_recording\",\"group\":\"main\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatejvtn1isu\",\"name\":\"hydraharp400_HeaderGenerator_download\",\"group\":\"main\",\"info\":\"\",\"config\":\"\"},{\"id\":\"ri_templatejezi0bbr\",\"name\":\"TimeTagger\",\"group\":\"main\",\"info\":\"游닋 [0, 1]\",\"config\":\"[2,0]\"},{\"id\":\"vi_templatejfc9koma\",\"name\":\"DL0-2\",\"group\":\"main\",\"info\":\"游닌 [0], 游닋 [2] \",\"config\":\"\"},{\"id\":\"vi_templatejg59migx\",\"name\":\"DL1-3\",\"group\":\"main\",\"info\":\"游닌 [1], 游닋 [3] \",\"config\":\"\"},{\"id\":\"vi_templatejg52ksbp\",\"name\":\"Correlationbwd\",\"group\":\"main\",\"info\":\"游닌 [3, 2], 游닋 [] \",\"config\":\"\"},{\"id\":\"vi_templatejfb2qshf\",\"name\":\"Correlationfwd\",\"group\":\"main\",\"info\":\"游닌 [2, 3], 游닋 [] \",\"config\":\"\"}]","var_templatejkil6yh0":null,"var_templatejkil7pz1":null,"var_templatejkil8r7x":null,"var_templatejkil9dn6":null,"dpp_templatejouvphfp":"#This Script Panel will start the time tagging on a quTAG device\r\n#TODO:20181124 This script is not yet tested \r\nfrom ctypes import *\r\nimport time,sys,os\r\nif not os.path.isfile(\"tdcbase.dll\"):\r\n    eta.send(\"Installing ETA DLC... \", \"running\")\r\n    import webinstall\r\n    webinstall.web_install(\"https://github.com/timetag/timetag.github.io/releases/download/qutaglib/quTAGlibV1.4.1.zip\",\"./\",\"quTAGlibV141.zip\")\r\n    eta.send(\"ETA DLC installed. \", \"stopped\")\r\ntry:\r\n    qutag = cdll.LoadLibrary(\"tdcbase.dll\")\r\nexcept Exception:\r\n    eta.send(\"You need to copy tdcbase.dll along with other dlls to the same folder of ETA-Backend.exe\",\"err\")\r\n    #You can find those DLLs from the 64bit library at\r\n    #https://www.qutools.com/\r\n    #You might also need a newer version of quTAG driver that allows configuration of the filters\r\nqutag.TDC_getVersion.restype=c_double\r\nprint(qutag.TDC_getVersion())\r\nrc = qutag.TDC_init( -1 )\r\nprint( \"TDC_init\", rc )\r\nrc = qutag.TDC_enableChannels( 0xff ) # Use all channels \r\nprint( \"TDC_enableChannels\", rc )\r\n\r\n#use two channes(2) in a Coinc filter configuration(2), and set all of the channels as enabled(3)\r\nrc = qutag.TDC_configureFilter(2,2,3) #TODO: this line is not yet tested\r\nprint( \"TDC_configureFilter\", rc )\r\n\r\nfilename= str(file).encode(\"utf-8\")\r\neta.send(\"Timetags will be written to {}\".format(filename))\r\neta.send(\"ETA starting reading the timetags from device...\", \"running\")\r\nrc = qutag.TDC_writeTimestamps(create_string_buffer(filename),1)#start acquisition\r\nprint( \"TDC_writeTimestamps\", rc )\r\ntime.sleep(10)\r\nrc = qutag.TDC_writeTimestamps(POINTER(c_int)(),1)#stop acquisition\r\nprint( \"TDC_writeTimestamps\", rc )\r\neta.send(\"ETA realtime is stopped.\", \"stopped\")","dpp_templatejouvvpsn":"import sys\r\ntry:\r\n    import TimeTagger\r\nexcept:\r\n    print(\"Time Tagger lib is not in the search path.\")\r\n    pyversion = sys.version_info\r\n    from winreg import ConnectRegistry, OpenKey, HKEY_LOCAL_MACHINE, QueryValueEx\r\n    registry_path = \"SOFTWARE\\\\Python\\\\PythonCore\\\\\" + \\\r\n        str(pyversion.major) + \".\" + str(pyversion.minor) + \"\\\\PythonPath\\\\Time Tagger\"\r\n    reg = ConnectRegistry(None, HKEY_LOCAL_MACHINE)\r\n    key = OpenKey(reg, registry_path)\r\n    module_path = QueryValueEx(key, '')[0]\r\n    print(\"adding \" + module_path)\r\n    sys.path.append(module_path)\r\nimport TimeTagger\r\n\r\nfrom time import sleep\r\n\r\ntagger = TimeTagger.createTimeTagger()\r\ntagger.reset();\r\n#disabling the test signals\r\ntagger.setTestSignal(0, False)\r\ntagger.setTestSignal(1, False)\r\ntagger.setTestSignal(5, False)\r\n#setTriggerLevel to chn0 ,chn1, chn5\r\ntagger.setTriggerLevel(0, 0.1)\r\ntagger.setTriggerLevel(1, 0.1)\r\ntagger.setTriggerLevel(5, 0.1)\r\ntagger.sync()\r\ncountrate =  TimeTagger.Countrate( tagger, channels=[0,1,5] )\r\nsleep(1)\r\neta.send('countrate:')\r\neta.send(countrate.getData())\r\n\r\neta.send('starting time-tagging',\"running\")\r\ndump =  TimeTagger.Dump(tagger,'swebian.bin',100000,[0,1,5])\r\nsleep(10)\r\neta.send('stopping time-tagging', \"stopped\")","dpp_templatejouvx190":"#TODO(20181124) This script is not yet tested on a real device.\n\n# Demo for access to HydraHarp 400 Hardware via HHLIB.DLL v 3.0.\n# The program performs a measurement based on hard coded settings.\n# The resulting data is stored in a binary output file.\n#\n# Keno Goertz, PicoQuant GmbH, February 2018\n\"\"\"\nDisclaimer\nPicoQuant GmbH disclaims all warranties with regard to this software and associated\ndocumentation including all implied warranties of merchantability and fitness. \nIn no case shall PicoQuant GmbH be liable for any direct, indirect or consequential\ndamages or any material or immaterial damages whatsoever resulting from loss of data,\ntime or profits arising from use or performance of this software.\n\"\"\"\nimport time\nimport ctypes as ct\nfrom ctypes import byref\nimport sys\nimport struct\n\n# From hhdefin.h\nLIB_VERSION = \"3.0\"\nMAXDEVNUM = 8\nMODE_T2 = 2\nMODE_T3 = 3\nMAXLENCODE = 6\nHHMAXINPCHAN = 8\nTTREADMAX = 131072\nFLAG_OVERFLOW = 0x0001\nFLAG_FIFOFULL = 0x0002\n\n# Measurement parameters, these are hardcoded since this is just a demo\nmode = MODE_T2 # set T2 or T3 here, observe suitable Syncdivider and Range!\nbinning = 0 # you can change this, meaningful only in T3 mode\noffset = 0 # you can change this, meaningful only in T3 mode\ntacq = 1000 # Measurement time in millisec, you can change this\nsyncDivider = 1 # you can change this, observe mode! READ MANUAL!\nsyncCFDZeroCross = 10 # you can change this (in mV)\nsyncCFDLevel = 50 # you can change this (in mV)\nsyncChannelOffset = -5000 # you can change this (in ps, like a cable delay)\ninputCFDZeroCross = 10 # you can change this (in mV)\ninputCFDLevel = 50 # you can change this (in mV)\ninputChannelOffset = 0 # you can change this (in ps, like a cable delay)\n\n# Variables to store information read from DLLs\nbuffer = (ct.c_uint * TTREADMAX)()\ndev = []\nlibVersion = ct.create_string_buffer(b\"\", 8)\nhwSerial = ct.create_string_buffer(b\"\", 8)\nhwPartno = ct.create_string_buffer(b\"\", 8)\nhwVersion = ct.create_string_buffer(b\"\", 8)\nhwModel = ct.create_string_buffer(b\"\", 16)\nerrorString = ct.create_string_buffer(b\"\", 40)\nnumChannels = ct.c_int()\nresolution = ct.c_double()\nsyncRate = ct.c_int()\ncountRate = ct.c_int()\nflags = ct.c_int()\nnRecords = ct.c_int()\nctcstatus = ct.c_int()\nwarnings = ct.c_int()\nwarningstext = ct.create_string_buffer(b\"\", 16384)\n\ntry:\n    hhlib = ct.CDLL(\"hhlib64.dll\")\nexcept Exception, e:\n    eta.send(\"hhlib64.dll not found. Please copy it to the folder of ETA-Backend.exe\",\"err\")\n    \ndef closeDevices():\n    for i in range(0, MAXDEVNUM):\n        hhlib.HH_CloseDevice(ct.c_int(i))\n    exit(0)\n\ndef stoptttr():\n    retcode = hhlib.HH_StopMeas(ct.c_int(dev[0]))\n    if retcode < 0:\n        print(\"HH_StopMeas error %1d. Aborted.\" % retcode)\n    closeDevices()\n\ndef tryfunc(retcode, funcName, measRunning=False):\n    if retcode < 0:\n        hhlib.HH_GetErrorString(errorString, ct.c_int(retcode))\n        print(\"HH_%s error %d (%s). Aborted.\" % (funcName, retcode,\\\n              errorString.value.decode(\"utf-8\")))\n        if measRunning:\n            stoptttr()\n        else:\n            closeDevices()\n\nhhlib.HH_GetLibraryVersion(libVersion)\nprint(\"Library version is %s\" % libVersion.value.decode(\"utf-8\"))\nif libVersion.value.decode(\"utf-8\") != LIB_VERSION:\n    print(\"Warning: The application was built for version %s\" % LIB_VERSION)\n\noutputfile = open(\"tttrmode.out\", \"wb+\")\n\nprint(\"\\nMode             : %d\" % mode)\nprint(\"Binning           : %d\" % binning)\nprint(\"Offset            : %d\" % offset)\nprint(\"AcquisitionTime   : %d\" % tacq)\nprint(\"SyncDivider       : %d\" % syncDivider)\nprint(\"SyncCFDZeroCross  : %d\" % syncCFDZeroCross)\nprint(\"SyncCFDLevel      : %d\" % syncCFDLevel)\nprint(\"InputCFDZeroCross : %d\" % inputCFDZeroCross)\nprint(\"InputCFDLevel     : %d\" % inputCFDLevel)\n\nprint(\"\\nSearching for HydraHarp devices...\")\nprint(\"Devidx     Status\")\n\nfor i in range(0, MAXDEVNUM):\n    retcode = hhlib.HH_OpenDevice(ct.c_int(i), hwSerial)\n    if retcode == 0:\n        print(\"  %1d        S/N %s\" % (i, hwSerial.value.decode(\"utf-8\")))\n        dev.append(i)\n    else:\n        if retcode == -1: # HH_ERROR_DEVICE_OPEN_FAIL\n            print(\"  %1d        no device\" % i)\n        else:\n            hhlib.HH_GetErrorString(errorString, ct.c_int(retcode))\n            print(\"  %1d        %s\" % (i, errorString.value.decode(\"utf8\")))\n\n# In this demo we will use the first HydraHarp device we find, i.e. dev[0].\n# You can also use multiple devices in parallel.\n# You can also check for specific serial numbers, so that you always know \n# which physical device you are talking to.\n\nif len(dev) < 1:\n    print(\"No device available.\")\n    closeDevices()\nprint(\"Using device #%1d\" % dev[0])\nprint(\"\\nInitializing the device...\")\n\n# with internal clock\ntryfunc(hhlib.HH_Initialize(ct.c_int(dev[0]), ct.c_int(mode), ct.c_int(0)),\\\n        \"Initialize\")\n\n# Only for information\ntryfunc(hhlib.HH_GetHardwareInfo(dev[0], hwModel, hwPartno, hwVersion),\\\n        \"GetHardwareInfo\")\nprint(\"Found Model %s Part no %s Version %s\" % (hwModel.value.decode(\"utf-8\"),\\\n      hwPartno.value.decode(\"utf-8\"), hwVersion.value.decode(\"utf-8\")))\n\ntryfunc(hhlib.HH_GetNumOfInputChannels(ct.c_int(dev[0]), byref(numChannels)),\\\n        \"GetNumOfInputChannels\")\nprint(\"Device has %i input channels.\" % numChannels.value)\n\nprint(\"\\nCalibrating...\")\ntryfunc(hhlib.HH_Calibrate(ct.c_int(dev[0])), \"Calibrate\")\ntryfunc(hhlib.HH_SetSyncDiv(ct.c_int(dev[0]), ct.c_int(syncDivider)), \"SetSyncDiv\")\n\ntryfunc(\n    hhlib.HH_SetSyncCFD(ct.c_int(dev[0]), ct.c_int(syncCFDLevel),\n                        ct.c_int(syncCFDZeroCross)),\\\n    \"SetSyncCFD\"\n)\n\ntryfunc(hhlib.HH_SetSyncChannelOffset(ct.c_int(dev[0]), ct.c_int(syncChannelOffset)),\\\n        \"SetSyncChannelOffset\")\n\n# we use the same input settings for all channels, you can change this\nfor i in range(0, numChannels.value):\n    tryfunc(\n        hhlib.HH_SetInputCFD(ct.c_int(dev[0]), ct.c_int(i), ct.c_int(inputCFDLevel),\\\n                             ct.c_int(inputCFDZeroCross)),\\\n        \"SetInputCFD\"\n    )\n\n    tryfunc(\n        hhlib.HH_SetInputChannelOffset(ct.c_int(dev[0]), ct.c_int(i),\\\n                                       ct.c_int(inputChannelOffset)),\\\n        \"SetInputChannelOffset\"\n    )\n\n# Meaningful only in T3 mode\nif mode == MODE_T3:\n    tryfunc(hhlib.HH_SetBinning(ct.c_int(dev[0]), ct.c_int(binning)), \"SetBinning\")\n    tryfunc(hhlib.HH_SetOffset(ct.c_int(dev[0]), ct.c_int(offset)), \"SetOffset\")\n    tryfunc(hhlib.HH_GetResolution(ct.c_int(dev[0]), byref(resolution)), \"GetResolution\")\n    print(\"Resolution is %1.1lfps\" % resolution.value)\n\n# Note: after Init or SetSyncDiv you must allow >100 ms for valid  count rate readings\ntime.sleep(0.2)\n\ntryfunc(hhlib.HH_GetSyncRate(ct.c_int(dev[0]), byref(syncRate)), \"GetSyncRate\")\nprint(\"\\nSyncrate=%1d/s\" % syncRate.value)\n\nfor i in range(0, numChannels.value):\n    tryfunc(hhlib.HH_GetCountRate(ct.c_int(dev[0]), ct.c_int(i), byref(countRate)),\\\n            \"GetCountRate\")\n    print(\"Countrate[%1d]=%1d/s\" % (i, countRate.value))\n\nprogress = 0\nsys.stdout.write(\"\\nProgress:%9u\" % progress)\nsys.stdout.flush()\n\ntryfunc(hhlib.HH_StartMeas(ct.c_int(dev[0]), ct.c_int(tacq)), \"StartMeas\")\n\nwhile True:\n    tryfunc(hhlib.HH_GetFlags(ct.c_int(dev[0]), byref(flags)), \"GetFlags\")\n    \n    if flags.value & FLAG_FIFOFULL > 0:\n        print(\"\\nFiFo Overrun!\")\n        stoptttr()\n    \n    tryfunc(\n        hhlib.HH_ReadFiFo(ct.c_int(dev[0]), byref(buffer), TTREADMAX,\\\n                          byref(nRecords)),\\\n        \"ReadFiFo\", measRunning=True\n    )\n\n    if nRecords.value > 0:\n        # We could just iterate through our buffer with a for loop, however,\n        # this is slow and might cause a FIFO overrun. So instead, we shrinken\n        # the buffer to its appropriate length with array slicing, which gives\n        # us a python list. This list then needs to be converted back into\n        # a ctype array which can be written at once to the output file\n        outputfile.write((ct.c_uint*nRecords.value)(*buffer[0:nRecords.value]))\n        progress += nRecords.value\n        sys.stdout.write(\"\\rProgress:%9u\" % progress)\n        sys.stdout.flush()\n    else:\n        tryfunc(hhlib.HH_CTCStatus(ct.c_int(dev[0]), byref(ctcstatus)),\\\n                \"CTCStatus\")\n        if ctcstatus.value > 0: \n            print(\"\\nDone\")\n            stoptttr()\n    # within this loop you can also read the count rates if needed.\n\ncloseDevices()\noutputfile.close()\n","dpp_templatejvtn1isu":"#This Script Panel will start the time tagging on a quTAG device\r\n#TODO:20181124 This script is not yet tested \r\nfrom ctypes import *\r\nimport time,sys,os\r\neta.send(\"Installing ETA DLC... \", \"running\")\r\nimport webinstall\r\nwebinstall.web_install(\"https://github.com/timetag/timetag.github.io/releases/download/HH400_HG/HH400HeaderGenerator.zip\",\"./\",\"HH400HeaderGenerator.zip\")\r\neta.send(\"ETA DLC installed.\", \"stopped\")\r\neta.send(\"Please find the LabVIEW code at \"+os.getcwd()+\"\\\\HH400HeaderGenerator\")\r\nos.startfile(os.getcwd()+\"\\\\HH400HeaderGenerator\")"}