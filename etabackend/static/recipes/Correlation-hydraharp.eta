{"vi_templatejg59migx":"{\"nodes\":[{\"x\":101,\"y\":101,\"fixed\":true,\"text\":\"a\",\"px\":101,\"py\":101,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"1\"}],\"usercode\":\"a:\\n    emit(4,`bw_delay`)# here, ch1 is duplicated to ch3 with a delay of 0ps\"}","vi_templatejfc9koma":"{\"nodes\":[{\"x\":82,\"y\":88,\"fixed\":true,\"text\":\"a\",\"px\":82,\"py\":88,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"0\"}],\"usercode\":\"a:\\n    emit(3,`fw_delay`)# here, ch0 is duplicated to ch2 with a delay of 0ps\"}","vi_templatejg52ksbp":"{\"nodes\":[{\"x\":346,\"y\":111,\"fixed\":true,\"text\":\"start\",\"px\":346,\"py\":111},{\"x\":95,\"y\":102,\"fixed\":true,\"text\":\"stop\",\"px\":95,\"py\":102,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"4\"},{\"source\":1,\"target\":0,\"text\":\"3\"},{\"source\":0,\"target\":0,\"text\":\"3\"},{\"source\":1,\"target\":1,\"text\":\"4\"}],\"usercode\":\"HISTOGRAM(h4,(`bins`,`binsize`,\\\"time-1\\\"))\\nHISTOGRAM(h4_zero,(1,1))\\nCLOCK(c4,100,1)\\nstart:\\n    c4.start()\\nstop:\\n    c4.stop()\\n    h4.record_all(c4)\\n    h4_zero.record_all(c4)\"}","vi_templatejfb2qshf":"{\"nodes\":[{\"x\":346,\"y\":111,\"fixed\":true,\"text\":\"start\",\"px\":346,\"py\":111},{\"x\":102,\"y\":102,\"fixed\":true,\"text\":\"stop\",\"px\":102,\"py\":102,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"3\"},{\"source\":1,\"target\":0,\"text\":\"4\"},{\"source\":0,\"target\":0,\"text\":\"4\"},{\"source\":1,\"target\":1,\"text\":\"3\"}],\"usercode\":\"HISTOGRAM(h3,(`bins`,`binsize`))\\nCLOCK(c3,100,1)\\nstart:\\n    c3.start()\\nstop:\\n    c3.stop()\\n    h3.record_all(c3)\"}","eta_index_table":"[{\"id\":\"var_templatejgmgopco\",\"name\":\"file\",\"group\":\"T2,T3\",\"info\":\"\",\"config\":\"C:/YourFolder/YourFile.timeres\"},{\"id\":\"var_templatejkim8l39\",\"name\":\"binsize\",\"group\":\"T2,T3\",\"info\":\"\",\"config\":\"16\"},{\"id\":\"var_templatejkim8rzm\",\"name\":\"expname\",\"group\":\"T2,T3\",\"info\":\"\",\"config\":\"Correlation\"},{\"id\":\"var_templatejkim8w21\",\"name\":\"bins\",\"group\":\"T2,T3\",\"info\":\"\",\"config\":\"10000\"},{\"id\":\"var_templatek71lu4ak\",\"name\":\"records_per_cut\",\"group\":\"T2,T3\",\"info\":\"\",\"config\":\"2e5\"},{\"id\":\"var_templatek7uj6ou8\",\"name\":\"HH400_mode\",\"group\":\"T2,T3\",\"info\":\"\",\"config\":\"T3\"},{\"id\":\"var_templatek8g3kag4\",\"name\":\"delay\",\"group\":\"T2,T3\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"var_templatek8g498fo\",\"name\":\"bw_delay\",\"group\":\"T2,T3\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"var_templatek8g49hcs\",\"name\":\"fw_delay\",\"group\":\"T2,T3\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"dpp_templatek7r3sgz1\",\"name\":\"display\",\"group\":\"T2,T3\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatek88yfdpn\",\"name\":\"static display\",\"group\":\"T2,T3\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatek0e4ffk5\",\"name\":\"save txt\",\"group\":\"T2,T3\",\"info\":\"\",\"config\":\"\"},{\"id\":\"vi_templatek6z7rk2w\",\"name\":\"HH400\",\"group\":\"T2,T3\",\"info\":\"游닆[0, 1, 2] \",\"config\":\"\"},{\"id\":\"vi_templatek0e44hsk\",\"name\":\"DL1-3 (T2)\",\"group\":\"T2\",\"info\":\"游닌[1] 游닋[3] \",\"config\":\"\"},{\"id\":\"vi_templatek0e44v54\",\"name\":\"DL2-4 (T2)\",\"group\":\"T2\",\"info\":\"游닌[2] 游닋[4] \",\"config\":\"\"},{\"id\":\"vi_templatejfc9koma\",\"name\":\"DL0-3 (T3)\",\"group\":\"T3\",\"info\":\"游닌[0] 游닋[3] \",\"config\":\"\"},{\"id\":\"vi_templatejg59migx\",\"name\":\"DL1-4 (T3)\",\"group\":\"T3\",\"info\":\"游닌[1] 游닋[4] \",\"config\":\"\"},{\"id\":\"vi_templatejg52ksbp\",\"name\":\"backward correlation\",\"group\":\"T2,T3\",\"info\":\"游닌[4, 3] \",\"config\":\"\"},{\"id\":\"vi_templatejfb2qshf\",\"name\":\"forward correlation\",\"group\":\"T2,T3\",\"info\":\"游닌[3, 4] \",\"config\":\"\"}]","var_templatejgmgopco":null,"var_templatejkim8l39":null,"var_templatejkim8rzm":null,"var_templatejkim8w21":null,"vi_templatek0e44hsk":"{\"nodes\":[{\"x\":82,\"y\":88,\"fixed\":true,\"text\":\"a\",\"px\":82,\"py\":88,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"1\"}],\"usercode\":\"a:\\n    emit(3,`fw_delay`)# here, ch0 is duplicated to ch2 with a delay of 0ps\"}","vi_templatek0e44v54":"{\"nodes\":[{\"x\":101,\"y\":101,\"fixed\":true,\"text\":\"a\",\"px\":101,\"py\":101,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"2\"}],\"usercode\":\"a:\\n    emit(4,`bw_delay`)# here, ch1 is duplicated to ch3 with a delay of 0ps\"}","dpp_templatek0e4ffk5":"#------IMPORTS-----\r\nfrom pathlib import Path\r\nimport numpy as np\r\n\r\ndef get_files(extensions):\r\n    global path\r\n    all_files = []\r\n    for ext in extensions:\r\n        all_files.extend(path.glob(ext))\r\n    return all_files\r\n    \r\ndef info(filename, binsize=binsize, bins=bins):\r\n    return (f'Created with ETA - https://timetag.github.io\\n'\r\n            f'filename: {filename.name}\\n'\r\n            f'binsize: {binsize}\\n'\r\n            f'bins: {bins}\\n'\r\n            f'mode: {lambda HH400_mode: HH400_mode if HH400_mode in globals() else \"qutag\"}\\n'\r\n            )\r\n\r\n#------ADJUST DELAY-----\r\ndelay = int(float(delay))\r\neta.recipe.set_parameter(\"bw_delay\",str(max(0,-1*delay)))\r\neta.recipe.set_parameter(\"fw_delay\",str(max(0,delay)))\r\neta.load_recipe()\r\n\r\n#------ETA PROCESSING-----\r\nbinsize=int(float(binsize))\r\npath = Path(file)\r\ndatafolder='analyzed data'\r\n\r\nselector = (f for f in get_files(('*.ptu','*.timeres'))) if path.is_dir() else [path]\r\n\r\nfor f in selector:\r\n        cutfile = eta.clips(f)\r\n        result=eta.run({\"timetagger1\":cutfile}, group=HH400_mode)\r\n        hist1=result[\"h3\"]\r\n        hist2=result[\"h4\"] \r\n        hist0=result[\"h4_zero\"]\r\n        hist1[0]+= hist0[0]\r\n        fullhist=np.concatenate((hist2[::-1],hist1))\r\n        f.parent.joinpath(datafolder).mkdir(parents=True, exist_ok=True)\r\n        np.savetxt(f.parent.joinpath(datafolder, f.stem + '_correlation' +  '.txt'), np.transpose([np.arange(-hist2.size,hist1.size)*binsize,fullhist]), delimiter='\\t', header=info(f))\r\n        eta.send(str(f.name) + ' has been successfully processed')\r\neta.send('FINISHED')\r\n\r\n","vi_templatek6z7rk2w":"{\"nodes\":[{\"x\":129,\"y\":62,\"fixed\":true,\"initial\":true}],\"edges\":[],\"usercode\":\"\\n########## click Help on the menu to get started! ##########\\nRFILE(timetagger1,[0,1,2])\"}","var_templatek71lu4ak":null,"dpp_templatek7r3sgz1":"import time\r\nimport pathlib\r\nimport logging\r\n\r\nimport queue\r\n\r\nimport numpy as np\r\n\r\nfrom bokeh.application import Application\r\nfrom bokeh.application.handlers.function import FunctionHandler\r\nfrom bokeh.layouts import column, row, widgetbox\r\nfrom bokeh.models.widgets import RadioButtonGroup, Button\r\nimport bokeh.plotting as bplt\r\nfrom bokeh.models import Range1d, BoxZoomTool\r\n\r\nlogger = logging.getLogger('etabackend.frontend')\r\n\r\nlogger.info(\"ETA realtime is started.\")\r\n\r\nrecords_per_cut = int(float(records_per_cut)\r\n                      ) if records_per_cut != \"\" else None\r\n\r\nSIMULATE_GROWTH = True\r\nDATAFOLDER = 'analyzed data'\r\nLABEL = 'histogram'\r\n\r\nbinsize = int(float(binsize))\r\nbins = int(float(bins))\r\nbin_factor = int(float(binsize))\r\nfile = pathlib.Path(file)\r\n\r\n#------ADJUST DELAY-----\r\ndelay = int(float(delay))\r\neta.recipe.set_parameter(\"bw_delay\",str(max(0,-1*delay)))\r\neta.recipe.set_parameter(\"fw_delay\",str(max(0,delay)))\r\neta.load_recipe()\r\n\r\nclass DataPlot(object):\r\n    def __init__(self, file, bins, bin_factor,\r\n                 records_per_cut=None, interval=100):\r\n        \"\"\" Calculates the next cut and writes it to the plot\r\n            file: str or Path of file currently investigated\r\n            bin_factor: The multiplication factor for each bin.\r\n            interval: The interval of the simulation\r\n            timeout: How long to wait for enough data until frame is skipped (milliseconds)\r\n        \"\"\"\r\n        global SIMULATE_GROWTH\r\n        \r\n        self.logger = logging.getLogger('etabackend.frontend')\r\n        \r\n        self.file = file\r\n        self.bins = bins\r\n        self.bin_factor = bin_factor\r\n        self.records_per_cut = records_per_cut\r\n\r\n        self.interval = interval\r\n        self.process_queue = queue.SimpleQueue()\r\n        self.set_accumulation_mode()\r\n        \r\n        # First cut to detect file properties and rate estimation\r\n        self.cut = eta.clip_file(\r\n            self.file, modify_clip=None, read_events=1, format=-1, wait_timeout=0)\r\n\r\n        if self.records_per_cut is None:\r\n            self.estimate_growth()\r\n\r\n        self.context = None\r\n        \r\n        if SIMULATE_GROWTH is False:\r\n            file_size = self.file.stat().st_size\r\n            file_size = file_size - self.cut.fseekpoint\r\n            existing_records = file_size//self.cut.BytesofRecords\r\n        else:\r\n            existing_records = self.records_per_cut\r\n            self.logger.info(\"Simulate Growth is activated.\")\r\n        \r\n        self.cut = eta.clip_file(self.file, modify_clip=None,\r\n                                 read_events=existing_records, wait_timeout=0.5)  # Start always from begining of file\r\n\r\n        result, self.context = eta.run({\"timetagger1\":self.cut}, resume_task=None, group=HH400_mode,\r\n                                       return_task=True,\r\n                                       return_results=True, max_autofeed=1)\r\n        self.hist1 = result['h3']\r\n        self.hist2 = result['h4']\r\n        self.hist0 = result[\"h4_zero\"]\r\n        self.hist1[0] += self.hist0[0]\r\n        self.xdata = np.arange(-self.hist2.size, self.hist1.size)*self.bin_factor\r\n        self.ydata = np.concatenate((self.hist2[::-1],self.hist1))\r\n        self.lastupdate = time.time()\r\n                                      \r\n        self.max_value = np.amax(self.ydata)\r\n        self.y_max = self.max_value*1.5\r\n        \r\n    def info(self):\r\n        return (f'Created with ETA - https://timetag.github.io\\n'\r\n            f'filename: {self.file.name}\\n'\r\n            f'binsize: {self.bin_factor}\\n'\r\n            f'bins: {self.bins}\\n'\r\n            )\r\n            \r\n    def estimate_growth(self):\r\n        \"\"\" Estimates the grow rate per second, will sleep for 1000ms.\r\n        The event loop continues running.\r\n        \"\"\"\r\n        self.logger.info('Estimating File growth.')\r\n        file_size_old = self.file.stat().st_size\r\n        time.sleep(1)\r\n        file_size_new = self.file.stat().st_size\r\n        self.logger.info('Done.')\r\n        \r\n        self.growth_rate = (file_size_new - file_size_old) / \\\r\n            self.cut.BytesofRecords  # Bytes per record\r\n        self.records_per_cut = int(self.growth_rate * self.interval)\r\n\r\n    def set_accumulation_mode(self):\r\n        self.mode = 'accumulation'\r\n\r\n    def set_alignment_mode(self):\r\n        self.mode = 'align'\r\n\r\n    def toggle_mode(self, event):\r\n        if self.mode == 'align':\r\n            self.set_accumulation_mode()\r\n        elif self.mode == 'accumulation':\r\n            self.set_alignment_mode()\r\n\r\n    def bokeh_plot_document(self, doc):\r\n        ctx = {}\r\n        \r\n        ctx['lastupdate'] = self.lastupdate\r\n        ctx['source'] = bplt.ColumnDataSource({'x': self.xdata*1e-3, 'y': self.ydata })\r\n        \r\n        fig = bplt.figure()\r\n        fig.y_range.start=0\r\n        fig.x_range = Range1d(self.xdata[0]*1e-3,self.xdata[-1]*1e-3)\r\n        fig.step(x='x', y='y', source=ctx['source'])\r\n        fig.add_tools(BoxZoomTool(dimensions='width'))\r\n        fig.xaxis.axis_label = \"Time delay (ns)\"\r\n        fig.yaxis.axis_label = \"Histogram events\"\r\n        button_alignment = RadioButtonGroup(labels=[\"Accumulation\", \"Alignment\"], active=0)\r\n        #button_linlog = RadioButtonGroup(labels=[\"Linear\", \"Logarithmic\"], active=0)\r\n        button_save = Button(label=\"Save\")\r\n        button_alignment.on_click(self.bokeh_button_alignment_callback)\r\n        #button_linlog.on_click(self.bokeh_button_linlog_callback)\r\n        button_save.on_click(self.bokeh_button_save_callback)\r\n        buttons = column(\r\n                row(button_alignment, sizing_mode='stretch_width'),\r\n                row(button_save, sizing_mode='stretch_width'),sizing_mode='stretch_width')\r\n        doc.add_root(column(fig,buttons,sizing_mode='stretch_both'))\r\n        \r\n        doc.add_periodic_callback(lambda: self.bokeh_update(ctx), self.interval)\r\n        return doc\r\n        \r\n    def bokeh_button_save_callback(self):\r\n        global DATAFOLDER, LABEL\r\n        self.file.parent.joinpath(DATAFOLDER).mkdir(\r\n            parents=True, exist_ok=True)  # Create analyzed folder\r\n\r\n        file_index = 0\r\n        # create unique index for file\r\n        while self.file.parent.joinpath(DATAFOLDER, f\"{self.file.stem}_{LABEL}_{file_index:0=3d}.txt\").exists():\r\n            file_index += 1\r\n\r\n        np.savetxt(self.file.parent.joinpath(DATAFOLDER, f\"{self.file.stem}_{LABEL}_{file_index:0=3d}.txt\"),\r\n                           np.transpose([self.xdata, self.ydata]), delimiter='\\t', header=self.info())\r\n        \r\n    def bokeh_button_alignment_callback(self, new_value):\r\n        if new_value == 0: self.process_queue.put(self.set_accumulation_mode)\r\n        elif new_value == 1: self.process_queue.put(self.set_alignment_mode)\r\n    \r\n    def bokeh_update(self, ctx):\r\n        if ctx['lastupdate'] < self.lastupdate:\r\n            ctx['lastupdate'] = self.lastupdate\r\n            ctx['source'].data.update({'y': self.ydata})\r\n\r\n    def update(self):\r\n        check_ret = eta.clip_file(self.file, modify_clip=self.cut,\r\n                                  read_events=self.records_per_cut, wait_timeout=0.2)\r\n        if not check_ret:\r\n            # No new data available\r\n            return\r\n            \r\n        self.cut = check_ret  # save the ret to cut\r\n        context = self.context if self.mode == 'accumulation' else None\r\n        result, self.context = eta.run({\"timetagger1\":self.cut}, resume_task=context, group=HH400_mode,\r\n                                       return_task=True,\r\n                                       return_results=True, max_autofeed=1)\r\n\r\n        self.hist1 = result['h3']\r\n        self.hist2 = result['h4']\r\n        self.hist0 = result[\"h4_zero\"]\r\n        self.hist1[0] += self.hist0[0]\r\n        \r\n        self.lastupdate = time.time()\r\n        self.ydata = np.concatenate((self.hist2[::-1],self.hist1))\r\n\r\ndp = DataPlot(file, bins, bin_factor, records_per_cut, interval=200)\r\n\r\nnot_displaying = eta.display(Application(FunctionHandler(dp.bokeh_plot_document)), 'bokeh')\r\n\r\nlogger.info('No further log output for the realtime recipe.')\r\nlogger.setLevel(logging.WARNING)\r\n\r\nwhile not not_displaying.is_set():\r\n    dp.update()\r\n    \r\n    if SIMULATE_GROWTH:\r\n        not_displaying.wait(0.2)\r\n        \r\n    while not dp.process_queue.empty():\r\n        func = dp.process_queue.get(False)\r\n        if func: \r\n            func()\r\n\r\nlogger.setLevel(logging.INFO)\r\nlogger.info(\"ETA realtime is stopped.\")","var_templatek7uj6ou8":null,"dpp_templatek88yfdpn":"#------IMPORTS-----\n\nimport numpy as np\nimport pandas as pd\nfrom pathlib import Path\n\nimport etabackend.tk.plot as etaplt\n\n#------ADJUST DELAY-----\ndelay = int(float(delay))\neta.recipe.set_parameter(\"bw_delay\",str(max(0,-1*delay)))\neta.recipe.set_parameter(\"fw_delay\",str(max(0,delay)))\neta.load_recipe()\n\n#------ETA PROCESSING-----\ncut=eta.clips(Path(file))\nresult= eta.run({\"timetagger1\":cut}, group=HH400_mode)\nhist1=result[\"h3\"]\nhist2=result[\"h4\"]\nhist0=result[\"h4_zero\"]\nhist1[0]+= hist0[0]\n\nfullhist=np.concatenate((hist2[::-1],hist1))\nxdata = np.arange(-hist2.size,hist1.size)*int(float(binsize))\n\nf=Path(file)\nDATAFOLDER = 'analyzed data'\nLABEL = 'correlation'\n#------PLOTTING-----\n\ndf = pd.DataFrame(np.vstack((xdata, fullhist)).T, \n                  columns=['time bins', 'histogram events'])\ndf['log events'] = np.clip(df['histogram events'].values, 0.5, None)\n\ndef generate_doc(doc):\n    def info():\n        return (f'Created with ETA - https://timetag.github.io\\n'\n            f'filename: {f.name}\\n'\n            f'binsize: {binsize}\\n'\n            f'bins: {bins}\\n'\n            f'mode: {HH400_mode if \"HH400_mode\" in globals() else \"quTAG\"}\\n'\n            )\n            \n    root = etaplt.plot_histogram(df, f,  f.parent.joinpath(DATAFOLDER), \n                                 data_name=LABEL.capitalize(), file_label=LABEL.lower(), \n                                 info=info())\n    doc.add_root(root)\n    return doc\n\neta.display(generate_doc, 'bokeh')\n","var_templatek8g3kag4":null,"var_templatek8g498fo":null,"var_templatek8g49hcs":null}